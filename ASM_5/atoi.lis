     1                                  ;****************************************************************************************************************************
     2                                  ;* Program name: Non-deterministic Random Numbers                                                                           *
     3                                  ;* Copyright (C) 2025 Konner Rigby.                                                                                           *
     4                                  ;* This file is part of the Non-deterministic Random Numbers program.                                                       *
     5                                  ;****************************************************************************************************************************
     6                                  
     7                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3**
     8                                  ; Author information
     9                                  ; Author: Konner Rigby
    10                                  ;
    11                                  ; This file
    12                                  ;   File name: atoi.asm
    13                                  ;   Function: atoi
    14                                  ;   Purpose: Converts an ASCII string to a 64-bit integer.
    15                                  ;            Stops on the first non-digit character (like a newline).
    16                                  ;   Language: x86-64 Assembly
    17                                  ;   Syntax: Intel
    18                                  ;   Assembler: nasm -f elf64 -g -o atoi.o atoi.asm
    19                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2=========3**
    20                                  
    21                                  global atoi
    22                                  
    23                                  segment .text
    24                                  atoi:
    25                                      ; rdi = pointer to string
    26                                      ; returns integer in rax
    27                                      
    28 00000000 55                          push    rbp
    29 00000001 4889E5                      mov     rbp, rsp
    30                                      
    31 00000004 4831C0                      xor     rax, rax        ; rax = 0 (our accumulator)
    32 00000007 4831C9                      xor     rcx, rcx        ; rcx = 0 (our loop index)
    33 0000000A 41BA0A000000                mov     r10, 10         ; for multiplication
    34                                  
    35                                  parse_loop:
    36 00000010 4C0FB6040F                  movzx   r8, byte [rdi + rcx] ; Get current char
    37                                  
    38                                      ; Check for null terminator or newline
    39 00000015 4983F800                    cmp     r8, 0
    40 00000019 7421                        je      done
    41 0000001B 4983F80A                    cmp     r8, 10
    42 0000001F 741B                        je      done
    43                                  
    44                                      ; Check if it's a digit (ASCII '0' to '9')
    45 00000021 4983F830                    cmp     r8, '0'
    46 00000025 7C15                        jl      done            ; Not a digit (use signed jump)
    47 00000027 4983F839                    cmp     r8, '9'
    48 0000002B 7F0F                        jg      done            ; Not a digit (use signed jump)
    49                                  
    50                                      ; It's a digit. Convert from ASCII to integer.
    51 0000002D 4983E830                    sub     r8, '0'         ; r8 = r8 - 48
    52                                      
    53                                      ; Update accumulator: rax = (rax * 10) + digit
    54 00000031 49F7E2                      mul     r10             ; rdx:rax = rax * 10 (we assume no overflow)
    55 00000034 4C01C0                      add     rax, r8         ; Add the new digit
    56                                  
    57 00000037 48FFC1                      inc     rcx
    58 0000003A EBD4                        jmp     parse_loop
    59                                  
    60                                  done:
    61 0000003C 5D                          pop     rbp
    62 0000003D C3                          ret
