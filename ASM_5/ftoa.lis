     1                                  ;************************************************************************************************************
     2                                  ;* Program name: "Ftoa". "Flote to Analog". This program accepts a 64-bit                                   *
     3                                  ;* float number in IEEE754 format and converts it decimal-based string-formated representation of that number.*
     4                                  ;* Copyright (C) 2024 by Floyd Holliday                                                                     *
     5                                  ;* *
     6                                  ;* This program is free software: you can redistribute it and/or modify it under the terms of the GNU General *
     7                                  ;* Public License version 3 as published by the Free Software Foundation. This program is distributed in the  *
     8                                  ;* hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY*
     9                                  ;* or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details  A copy of the    *
    10                                  ;* GNU General Public License v3 is available here:  <https://www.gnu.org/licenses/>.                         *
    11                                  ;************************************************************************************************************
    12                                  
    13                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1
    14                                  ; Author information
    15                                  ;   Name: Floyd Holliday
    16                                  ;   Contact: holliday@fullerton.edu
    17                                  ;
    18                                  ; Program information
    19                                  ;   Program name: Test Ftoa
    20                                  ;   Programming languages: X86 (ftoa),  C++ (driver)
    21                                  ;   Date program development began Dec 28, 2024
    22                                  ;   Date of most recent update: Jan 20, 2025
    23                                  ;   Files: driver.cpp, ftoa.asm
    24                                  ;
    25                                  ; Function ftoa information
    26                                  ;   Function name: ftoa, an acronym for Float to Analog.
    27                                  ;   Version number: 1.0
    28                                  ;   License: GPL3.
    29                                  ;   Programming language: X86
    30                                  ;   Syntax:  Intel
    31                                  ;   Assemble instruction: nasm -f elf64 -l ftoa.lis -o ftoa.o ftoa.asm
    32                                  ;   Status: Final release.
    33                                  ;
    34                                  ; Prototype of ftoa:  char * ftoa(double x);
    35                                  ;
    36                                  ;========1=========2=========3=========4=========5=========6=========7=========8=========9=========0=========1=========2
    37                                  
    38                                  ;Declarations
    39                                  ascii_zero equ 48
    40                                  ascii_dot equ  46
    41                                  integer_ten equ 10
    42                                  string_len equ 64     ;The next programmer should take charge of setting string length
    43                                  null equ 0
    44                                  global ftoa
    45                                  
    46                                  segment .data
    47                                     
    48 00000000 6F6E6500                    mark db "one",0
    49                                  
    50                                  segment .bss
    51 00000000 <res 40h>                   number_string resb string_len
    52                                  
    53                                  segment .text
    54                                  ftoa:
    55                                      ; === Standard Prologue ===
    56 00000000 55                          push    rbp
    57 00000001 4889E5                      mov     rbp, rsp
    58 00000004 53                          push    rbx
    59 00000005 4154                        push    r12
    60 00000007 4155                        push    r13
    61 00000009 4156                        push    r14
    62 0000000B 4157                        push    r15
    63                                  
    64                                      ; Copy the passed in float number to xmm8
    65 0000000D F2440F10C0                  movsd   xmm8, xmm0
    66                                  
    67                                      ; === Block: Determine the sign of the incoming number ===
    68 00000012 41BF00000000                mov     r15, 0          ; r15 is the sign flag. 0 = positive
    69 00000018 660F57C0                    xorpd   xmm0, xmm0      ; Create a temporary zero in xmm0
    70 0000001C 66440F2EC0                  ucomisd xmm8, xmm0
    71 00000021 7706                        ja      continue
    72 00000023 41BF01000000                mov     r15, 1          ; 1 = negative
    73                                  continue:
    74                                  
    75                                      ; === Block: Replace xmm8 with its absolute value ===
    76 00000029 660F57C0                    xorpd   xmm0, xmm0
    77 0000002D F2410F5CC0                  subsd   xmm0, xmm8
    78 00000032 F2440F5FC0                  maxsd   xmm8, xmm0
    79                                  
    80                                      ; === Block: Extract integral part ===
    81                                      ; Remove the integral part of xmm8 and save that part as an unsigned integer in rax
    82 00000037 66410F3A0BF003              roundsd xmm6, xmm8, 3   ; 3 = truncate towards zero
    83 0000003E F2480F2DC6                  cvtsd2si rax, xmm6
    84                                  
    85 00000043 41BC00000000                mov     r12, 0          ; r12 will count the number of digits in the integral part
    86 00000049 4C8D2C25[00000000]          lea     r13, [number_string] ; r13 = pointer to our output string
    87                                  
    88                                  beginleftsideofdot:
    89 00000051 4983FC3F                    cmp     r12, string_len - 1 ; Check for space available in the string r13
    90 00000055 0F8DCB000000                jge     append_null
    91 0000005B 4883F800                    cmp     rax, 0          ; If rax == 0 then break out of the loop
    92 0000005F 7412                        je      outofloop
    93                                      
    94                                      ; Use div to get the last digit
    95 00000061 41BA0A000000                mov     r10, integer_ten
    96 00000067 4831D2                      xor     rdx, rdx        ; Clear rdx for 64-bit division
    97 0000006A 49F7F2                      div     r10             ; rax = rax / 10, rdx = remainder
    98                                      
    99 0000006D 52                          push    rdx             ; Push the remainder value
   100 0000006E 49FFC4                      inc     r12             ; Increment digit count
   101 00000071 EBDE                        jmp     beginleftsideofdot
   102                                  outofloop:
   103                                      ; rax is now 0; r12 has counted the number of pushes onto the stack
   104                                  
   105                                      ; Let r14 be the index into the array r13
   106 00000073 4D31F6                      xor     r14, r14
   107                                  
   108                                      ; === Block: Handle negative sign ===
   109 00000076 4983FF00                    cmp     r15, 0
   110 0000007A 740B                        je      positive
   111 0000007C 41C645002D                  mov     byte [r13], '-'
   112 00000081 49FFC6                      inc     r14
   113 00000084 49FFC4                      inc     r12             ; Account for the '-' char
   114                                  positive:
   115                                  
   116                                      ; === Block: Pop digits and build integer-part string ===
   117                                  leftsideofdot:
   118 00000087 4983FE40                    cmp     r14, string_len
   119 0000008B 0F8D95000000                jge     append_null
   120 00000091 4D39E6                      cmp     r14, r12
   121 00000094 7D0D                        jge     appenddot
   122 00000096 58                          pop     rax             ; The number popped is one of the decimal digits: 0..9
   123 00000097 0430                        add     al, ascii_zero  ; 48 equals the ascii value of zero
   124 00000099 4388443500                  mov     byte [r13 + r14], al
   125 0000009E 49FFC6                      inc     r14
   126 000000A1 EBE4                        jmp     leftsideofdot
   127                                  
   128                                  appenddot:
   129                                      ; Append one dot
   130 000000A3 43C64435002E                mov     byte [r13 + r14], ascii_dot
   131 000000A9 49FFC6                      inc     r14
   132                                  
   133                                      ; === Block: Convert fractional part ===
   134                                      ; Subtract the whole part from the original number leaving only the fractional part in xmm8.
   135 000000AC F2440F5CC6                  subsd   xmm8, xmm6
   136                                  
   137                                      ; Establish the constant 10.0 (ten decimal float)
   138 000000B1 41BA0A000000                mov     r10, 10
   139 000000B7 F24D0F2AD2                  cvtsi2sd xmm10, r10     ; xmm10 is the constant 10.0
   140                                  
   141                                  begin_fractional_loop:
   142                                      ; If the fractional part is 0.0, it is time to leave this loop.
   143 000000BC 660F57C0                    xorpd   xmm0, xmm0
   144 000000C0 66440F2EC0                  ucomisd xmm8, xmm0
   145 000000C5 742A                        je      out_of_loop
   146                                  
   147                                      ; If there is no available space in the destination array r13 then this loop must stop.
   148 000000C7 4983FE3F                    cmp     r14, string_len - 1
   149 000000CB 7D24                        jge     out_of_loop
   150                                  
   151 000000CD F2450F59C2                  mulsd   xmm8, xmm10     ; Multiply fraction by 10 (e.g., 0.456 -> 4.56)
   152 000000D2 66450F3A0BC803              roundsd xmm9, xmm8, 3   ; Truncate to get the whole part (e.g., 4.0)
   153 000000D9 F24D0F2DC9                  cvtsd2si r9, xmm9       ; Convert to integer (e.g., 4)
   154 000000DE 4983C130                    add     r9, ascii_zero  ; Convert to char '4'
   155 000000E2 47884C3500                  mov     [r13 + r14], r9b ; Store '4' in string
   156 000000E7 49FFC6                      inc     r14
   157 000000EA F2450F5CC1                  subsd   xmm8, xmm9      ; Subtract whole part (e.g., 4.56 - 4.0 = 0.56)
   158                                  
   159 000000EF EBCB                        jmp     begin_fractional_loop
   160                                  
   161                                  out_of_loop:
   162                                      ; --- trim trailing zeros from fractional part ---
   163                                  .trim:
   164 000000F1 4983FE00                    cmp     r14, 0
   165 000000F5 7418                        je      .maybe_add_zero
   166 000000F7 43807C35FF30                cmp     byte [r13 + r14 - 1], '0'
   167 000000FD 7505                        jne     .check_dot
   168 000000FF 49FFCE                      dec     r14
   169 00000102 EBED                        jmp     .trim
   170                                  
   171                                  .check_dot:
   172                                      ; if we stopped on '.', drop it (e.g., "10." -> "10")
   173 00000104 43807C35FF2E                cmp     byte [r13 + r14 - 1], ascii_dot
   174 0000010A 7503                        jne     .maybe_add_zero
   175 0000010C 49FFCE                      dec     r14
   176                                  
   177                                  .maybe_add_zero:
   178                                      ; if the last char is a '.', append a single '0' (e.g., "4." -> "4.0")
   179 0000010F 4983FE00                    cmp     r14, 0
   180 00000113 7411                        je      append_null
   181 00000115 43807C35FF2E                cmp     byte [r13 + r14 - 1], ascii_dot
   182 0000011B 7509                        jne     append_null
   183 0000011D 43C644350030                mov     byte [r13 + r14], ascii_zero
   184 00000123 49FFC6                      inc     r14
   185                                  
   186                                  append_null:
   187                                      ; Append the null char
   188 00000126 43C644350000                mov     byte [r13 + r14], null
   189 0000012C 49FFC6                      inc     r14
   190                                  
   191 0000012F 4C89E8                      mov     rax, r13        ; Send the string pointer back to the driver
   192                                      
   193                                      ; === Standard Epilogue ===
   194 00000132 415F                        pop     r15
   195 00000134 415E                        pop     r14
   196 00000136 415D                        pop     r13
   197 00000138 415C                        pop     r12
   198 0000013A 5B                          pop     rbx
   199 0000013B 5D                          pop     rbp
   200 0000013C C3                          ret
